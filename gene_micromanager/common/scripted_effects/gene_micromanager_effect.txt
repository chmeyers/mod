

# Cleanup our variables
gene_micromanage_cleanup = {
	clear_variable = possible_trait_points
	clear_variable = available_trait_picks
	clear_variable = needed_trait_points
	clear_variable = possible_trait_picks
	clear_variable = unaccounted_trait_points
	clear_variable = available_trait_points
}

# Remove a trait iff they own a subspecies that does not have that trait.
gene_micromanage_try_remove_trait = {
	if = {
		limit = {
			pop_has_trait = $TRAIT$
			owner = {
				any_owned_species = {
					is_same_species = event_target:base_species
					NOT = { has_trait = $TRAIT$ }
					# Cybernetic Trait has to match.
					OR = {
						AND = {
							has_trait = trait_cybernetic
							event_target:base_species = { has_trait = trait_cybernetic }
						}
						NOR = {
							has_trait = trait_cybernetic
							event_target:base_species = { has_trait = trait_cybernetic }
						}
					}
				}
			}
		}
		modify_species = {
			species = this
			change_scoped_species = yes
			remove_trait = $TRAIT$
		}
	}
}

# Remove a trait iff they have the trait points.
gene_micromanage_try_remove_negative_trait = {
	if = {
		limit = {
			pop_has_trait = $TRAIT$
			check_variable = { which = available_trait_points value >= $COST$ }
		}
		modify_species = {
			species = this
			change_scoped_species = yes
			remove_trait = $TRAIT$
		}
		set_pop_flag = had_negative_$TRAIT$
		subtract_variable = { which = available_trait_points value = $COST$ }
	}
}

# Remove traits that the species' main template does not have.
# This simulates reverting to a species template before customization.
# It's significantly more complicated, so we only do it when we aren't
# allowed to add/remove traits at will as we are with Genetic Ascension.
gene_micromanage_try_remove_traits = {
	optimize_memory
	species = {
		save_event_target_as = base_species
	}
	gene_micromanage_try_remove_trait = { TRAIT = trait_adaptive_lithoid }
	gene_micromanage_try_remove_trait = { TRAIT = trait_rapid_breeders_lithoid }
	gene_micromanage_try_remove_trait = { TRAIT = trait_delicious }
	gene_micromanage_try_remove_trait = { TRAIT = trait_nerve_stapled }
	gene_micromanage_try_remove_trait = { TRAIT = trait_fertile }
	gene_micromanage_try_remove_trait = { TRAIT = trait_robust }
	gene_micromanage_try_remove_trait = { TRAIT = trait_erudite }
	gene_micromanage_try_remove_trait = { TRAIT = trait_vat_grown }
	gene_micromanage_try_remove_trait = { TRAIT = trait_felsic }
	gene_micromanage_try_remove_trait = { TRAIT = trait_natural_machinist }
	gene_micromanage_try_remove_trait = { TRAIT = trait_incubator }
	gene_micromanage_try_remove_trait = { TRAIT = trait_agrarian }
	gene_micromanage_try_remove_trait = { TRAIT = trait_ingenious }
	gene_micromanage_try_remove_trait = { TRAIT = trait_industrious }
	gene_micromanage_try_remove_trait = { TRAIT = trait_intelligent }
	gene_micromanage_try_remove_trait = { TRAIT = trait_thrifty }
	gene_micromanage_try_remove_trait = { TRAIT = trait_natural_engineers }
	gene_micromanage_try_remove_trait = { TRAIT = trait_natural_physicists }
	gene_micromanage_try_remove_trait = { TRAIT = trait_natural_sociologists }
	gene_micromanage_try_remove_trait = { TRAIT = trait_extremely_adaptive }
	gene_micromanage_try_remove_trait = { TRAIT = trait_adaptive }
	gene_micromanage_try_remove_trait = { TRAIT = trait_rapid_breeders }
	gene_micromanage_try_remove_trait = { TRAIT = trait_talented }
	gene_micromanage_try_remove_trait = { TRAIT = trait_quick_learners }
	gene_micromanage_try_remove_trait = { TRAIT = trait_traditional }
	gene_micromanage_try_remove_trait = { TRAIT = trait_docile }
	gene_micromanage_try_remove_trait = { TRAIT = trait_very_strong }
	gene_micromanage_try_remove_trait = { TRAIT = trait_strong }
	gene_micromanage_try_remove_trait = { TRAIT = trait_nomadic }
	gene_micromanage_try_remove_trait = { TRAIT = trait_communal }
	gene_micromanage_try_remove_trait = { TRAIT = trait_charismatic }
	gene_micromanage_try_remove_trait = { TRAIT = trait_conformists }
	gene_micromanage_try_remove_trait = { TRAIT = trait_venerable }
	gene_micromanage_try_remove_trait = { TRAIT = trait_enduring }
	gene_micromanage_try_remove_trait = { TRAIT = trait_conservational }
	gene_micromanage_try_remove_trait = { TRAIT = trait_plantoid_radiotrophic }
	gene_micromanage_try_remove_trait = { TRAIT = trait_lithoid_radiotrophic }

	# For negatives, we have to count points first.
	gene_micromanage_count_traits = yes

	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_nonadaptive COST = 2 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_slow_breeders COST = 2 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_slow_learners COST = 1 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_quarrelsome COST = 1 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_unruly COST = 2 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_weak COST = 1 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_sedentary COST = 1 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_solitary COST = 1 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_repugnant COST = 2 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_deviants COST = 1 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_fleeting COST = 1 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_fleeting_lithoid COST = 1 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_decadent COST = 1 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_wasteful COST = 1 }
	gene_micromanage_try_remove_negative_trait = { TRAIT = trait_resilient COST = 1 }
}

# Remove every trait that we are willing to remove to leave a 
# clean slate for customization.
gene_micromanage_remove_traits = {
	optimize_memory
	if = {
		limit = { can_genemod_genetic = yes }
		modify_species = {
			species = this
			change_scoped_species = yes
			remove_trait = trait_adaptive_lithoid
			remove_trait = trait_rapid_breeders_lithoid
			remove_trait = trait_delicious
			remove_trait = trait_nerve_stapled
			remove_trait = trait_fertile
			remove_trait = trait_robust
			remove_trait = trait_erudite
			remove_trait = trait_vat_grown
			remove_trait = trait_felsic
			remove_trait = trait_natural_machinist
			remove_trait = trait_incubator
			remove_trait = trait_agrarian
			remove_trait = trait_ingenious
			remove_trait = trait_industrious
			remove_trait = trait_intelligent
			remove_trait = trait_thrifty
			remove_trait = trait_natural_engineers
			remove_trait = trait_natural_physicists
			remove_trait = trait_natural_sociologists
			remove_trait = trait_extremely_adaptive
			remove_trait = trait_adaptive
			remove_trait = trait_rapid_breeders
			remove_trait = trait_talented
			remove_trait = trait_quick_learners
			remove_trait = trait_traditional
			remove_trait = trait_docile
			remove_trait = trait_very_strong
			remove_trait = trait_strong
			remove_trait = trait_nomadic
			remove_trait = trait_communal
			remove_trait = trait_charismatic
			remove_trait = trait_conformists
			remove_trait = trait_venerable
			remove_trait = trait_enduring
			remove_trait = trait_conservational
			remove_trait = trait_plantoid_radiotrophic
			remove_trait = trait_lithoid_radiotrophic
			# Negative Traits
			remove_trait = trait_nonadaptive
			remove_trait = trait_slow_breeders
			remove_trait = trait_slow_learners
			remove_trait = trait_quarrelsome
			remove_trait = trait_unruly
			remove_trait = trait_weak
			remove_trait = trait_sedentary
			remove_trait = trait_solitary
			remove_trait = trait_repugnant
			remove_trait = trait_deviants
			remove_trait = trait_fleeting
			remove_trait = trait_fleeting_lithoid
			remove_trait = trait_decadent
			remove_trait = trait_wasteful
			remove_trait = trait_resilient
		}
		# Probably a bug on their side, but you can get the good enigmatic intelligence
		# trait with Erudite only if you were already erudite when it was initially added.
		# In that edge case, we don't remove Erudite.
		if = {
			limit = { NOT = { pop_has_trait = trait_enigmatic_intelligence } }
			modify_species = {
				species = this
				change_scoped_species = yes
				remove_trait = trait_erudite
			}
		}
		# These have additional requirements
		if = {
			limit = {
				NOT = { owner = { has_ascension_perk = ap_hydrocentric } }
			}
			modify_species = {
				species = this
				change_scoped_species = yes
				remove_trait = trait_aquatic
			}
		}
		if = {
			limit = {
				owner = { has_technology = tech_plantoid_transgenesis }
			}
			modify_species = {
				species = this
				change_scoped_species = yes
				remove_trait = trait_advanced_radiotrophic
			}
		}
	}
	if = {
		limit = { can_genemod_cybernetic = yes }
		modify_species = {
			species = this
			change_scoped_species = yes
			remove_trait = trait_cyborg_power_drills
			remove_trait = trait_cyborg_harvesters
			remove_trait = trait_cyborg_superconductive
			remove_trait = trait_cyborg_efficient_processors
			remove_trait = trait_cyborg_logic_engines
			remove_trait = trait_cyborg_loyalty_circuits
			remove_trait = trait_cyborg_double_jointed
			remove_trait = trait_cyborg_bulky
			remove_trait = trait_cyborg_enhanced_memory
			remove_trait = trait_cyborg_durable
			remove_trait = trait_cyborg_high_maintenance
			remove_trait = trait_cyborg_learning_algorithms
			remove_trait = trait_cyborg_power_intensive
			remove_trait = trait_cyborg_neural_limiters
			remove_trait = trait_cyborg_streamlined_protocols
			remove_trait = trait_cyborg_high_bandwidth
			remove_trait = trait_cyborg_trading_algorithms
		}
	}
	# Remove Overtuned traits only if we can add them back.
	if = {
		limit = {
			owner = { has_origin = origin_overtuned }
		}
		modify_species = {
			species = this
			change_scoped_species = yes
			remove_trait = trait_spliced_adaptability
			remove_trait = trait_juiced_power
			remove_trait = trait_farm_hands
			remove_trait = trait_crack_miner
			remove_trait = trait_technical_skill
			remove_trait = trait_crafted_smiles
			remove_trait = trait_low_maintenance
			remove_trait = trait_artificial_intelligence
			remove_trait = trait_gene_mentorship
			remove_trait = trait_expressed_tradition
			remove_trait = trait_elevated_synapses
			remove_trait = trait_preplanned_growth
			remove_trait = trait_excessive_endurance
		}
	}
	# Try to remove any genetic traits that we couldn't remove above by matching templates.
	if = {
		limit = { NOT = { can_genemod_genetic = yes } }
		gene_micromanage_try_remove_traits = yes
	}
}

gene_micromanage_reset_habitability =  {
	if = {
		limit = {
			owner = { has_technology = tech_glandular_acclimation }
			NOT = { pop_has_trait = trait_pc_nuked_preference }
			NOT = { pop_has_trait = trait_pc_habitat_preference }
			NOT = { pop_has_trait = trait_aquatic }
			NOT = { pop_has_trait = trait_self_modified }
			NOT = { home_planet = { is_artificial = yes } }
			NOT = { home_planet = { is_ideal = yes } }
			NOT = { home_planet = { is_planet_class = pc_relic } }
			NOT = { home_planet = { is_planet_class = pc_nuked } }
			NOT = { home_planet = { is_planet_class = pc_machine } }
			NOT = { home_planet = { is_planet_class = pc_hive } }
			NOT = { species = { is_half_species = any } }
			species = { exists = home_planet }
		}
		species = { home_planet = { save_event_target_as = current_home_planet } }
		modify_species = {
			species = this
			change_scoped_species = yes
			ideal_planet_class = event_target:current_home_planet
		}
	}
}

# Set their habitability
gene_micromanage_habitability =  {
	if = {
		# The aquatic trait requires ocean preference.
		limit = {
			pop_has_trait = trait_aquatic
			NOT = { pop_has_trait = trait_pc_ocean_preference }
		}
		modify_species = {
			species = this
			change_scoped_species = yes
			ideal_planet_class = pc_ocean
		}
	}
	else_if = {
		limit = {
			owner = { has_technology = tech_glandular_acclimation }
			NOT = { pop_has_trait = trait_pc_nuked_preference }
			NOT = { pop_has_trait = trait_pc_habitat_preference }
			NOT = { pop_has_trait = trait_aquatic }
			NOT = { pop_has_trait = trait_self_modified }
			NOT = { planet = { is_artificial = yes } }
			NOT = { planet = { is_ideal = yes } }
			NOT = { planet = { is_planet_class = pc_relic } }
			NOT = { planet = { is_planet_class = pc_nuked } }
			NOT = { planet = { is_planet_class = pc_machine } }
			NOT = { planet = { is_planet_class = pc_hive } }
			NOT = { planet = { is_ideal_planet_class = { who = prev.species status = yes } } }
			planet = { habitability = { who = prev.species value < 1.0 } }
		}
		planet = { save_event_target_as = current_planet }
		modify_species = {
			species = this
			change_scoped_species = yes
			ideal_planet_class = event_target:current_planet
		}
	}
	
}

gene_micromanage_add_negatives = {
	# We are willing to add these negative traits if we need extra points
	# trait_repugnant -2 (only if they don't produce amenities and aren't charismatic)
	# trait_fleeting -1
	# trait_slow_learners -1
	# trait_solitary -1
	set_variable = { which = possible_trait_picks value = available_trait_picks }
	# Need one pick for the positive trait, we never take the last pick with a negative.
	subtract_variable = { which = possible_trait_picks value = 1 }
	if = {
		limit = {
			# Don't add negatives if we don't have to.
			check_variable = { which = available_trait_points value < $WANT$ }
			check_variable = { which = possible_trait_picks value >= 1 }
		}
		# Figure out whether we can get enough points before actually adding any traits
		set_variable = { which = possible_trait_points value = available_trait_points }
		
		if = {
			limit = {
				check_variable = { which = possible_trait_picks value >= 1 }
				can_genemod_cybernetic = yes
				NOT = { pop_has_trait = trait_cyborg_neural_limiters }
			}
			change_variable = { which = possible_trait_points value = 2 }
			subtract_variable = { which = possible_trait_picks value = 1 }
		}
		if = {
			limit = {
				check_variable = { which = possible_trait_picks value >= 1 }
				OR = {
					can_genemod_genetic = yes
					has_pop_flag = had_negative_trait_repugnant
				}
				pop_job_produces_amenities = no
				NOT = { pop_has_trait = trait_charismatic }
				NOT = { pop_has_trait = trait_repugnant }
			}
			change_variable = { which = possible_trait_points value = 2 }
			subtract_variable = { which = possible_trait_picks value = 1 }
		}
		if = {
			limit = {
				check_variable = { which = possible_trait_picks value >= 1 }
				OR = {
					can_genemod_genetic = yes
					has_pop_flag = had_negative_trait_fleeting
					has_pop_flag = had_negative_trait_fleeting_lithoid
				}
				NOT = { pop_has_trait = trait_fleeting }
				NOT = { pop_has_trait = trait_fleeting_lithoid }
			}
			change_variable = { which = possible_trait_points value = 1 }
			subtract_variable = { which = possible_trait_picks value = 1 }
		}
		if = {
			limit = {
				check_variable = { which = possible_trait_picks value >= 1 }
				OR = {
					can_genemod_genetic = yes
					has_pop_flag = had_negative_trait_slow_learners
				}
				NOT = { pop_has_trait = trait_slow_learners }
			}
			change_variable = { which = possible_trait_points value = 1 }
			subtract_variable = { which = possible_trait_picks value = 1 }
		}
		if = {
			limit = {
				check_variable = { which = possible_trait_picks value >= 1 }
				OR = {
					can_genemod_genetic = yes
					has_pop_flag = had_negative_trait_solitary
				}
				NOT = { pop_has_trait = trait_solitary }
			}
			change_variable = { which = possible_trait_points value = 1 }
			subtract_variable = { which = possible_trait_picks value = 1 }
		}

		if = {
			limit = {
				check_variable = { which = possible_trait_points value >= $WANT$ }
			}
			# We can do it. Now actually add them.
			if = {
				limit = {
					can_genemod_cybernetic = yes
					NOT = { pop_has_trait = trait_cyborg_neural_limiters }
				}
				modify_species = {
					species = this
					change_scoped_species = yes
					add_trait = trait_cyborg_neural_limiters
				}
				change_variable = { which = available_trait_points value = 2 }
				subtract_variable = { which = available_trait_picks value = 1 }
			}
			if = {
				limit = {
					OR = {
						can_genemod_genetic = yes
						has_pop_flag = had_negative_trait_repugnant
					}
					pop_job_produces_amenities = no
					check_variable = { which = available_trait_points value < $WANT$ }
					NOT = { pop_has_trait = trait_charismatic }
					NOT = { pop_has_trait = trait_repugnant }
				}
				modify_species = {
					species = this
					change_scoped_species = yes
					add_trait = trait_repugnant
				}
				change_variable = { which = available_trait_points value = 2 }
				subtract_variable = { which = available_trait_picks value = 1 }
			}
			if = {
				limit = {
					is_lithoid = no
					OR = {
						can_genemod_genetic = yes
						has_pop_flag = had_negative_trait_fleeting
					}
					check_variable = { which = available_trait_points value < $WANT$ }
					NOT = { pop_has_trait = trait_fleeting }
				}
				modify_species = {
					species = this
					change_scoped_species = yes
					add_trait = trait_fleeting
				}
				change_variable = { which = available_trait_points value = 1 }
				subtract_variable = { which = available_trait_picks value = 1 }
			}
			if = {
				limit = {
					is_lithoid = yes
					OR = {
						can_genemod_genetic = yes
						has_pop_flag = had_negative_trait_fleeting_lithoid
					}
					check_variable = { which = available_trait_points value < $WANT$ }
					NOT = { pop_has_trait = trait_fleeting_lithoid }
				}
				modify_species = {
					species = this
					change_scoped_species = yes
					add_trait = trait_fleeting_lithoid
				}
				change_variable = { which = available_trait_points value = 1 }
				subtract_variable = { which = available_trait_picks value = 1 }
			}
			if = {
				limit = {
					OR = {
						can_genemod_genetic = yes
						has_pop_flag = had_negative_trait_slow_learners
					}
					check_variable = { which = available_trait_points value < $WANT$ }
					NOT = { pop_has_trait = trait_slow_learners }
				}
				modify_species = {
					species = this
					change_scoped_species = yes
					add_trait = trait_slow_learners
				}
				change_variable = { which = available_trait_points value = 1 }
				subtract_variable = { which = available_trait_picks value = 1 }
			}
			if = {
				limit = {
					OR = {
						can_genemod_genetic = yes
						has_pop_flag = had_negative_trait_solitary
					}
					check_variable = { which = available_trait_points value < $WANT$ }
					NOT = { pop_has_trait = trait_solitary }
					NOT = { pop_has_trait = trait_nerve_stapled }
				}
				modify_species = {
					species = this
					change_scoped_species = yes
					add_trait = trait_solitary
				}
				change_variable = { which = available_trait_points value = 1 }
				subtract_variable = { which = available_trait_picks value = 1 }
			}
		}
		
	}
}

# Anyone is allowed to add these traits.
gene_micromanage_try_add = {
	if = {
		limit = {
			NOT = { has_trait = $TRAIT$ }
		}
		# Add negatives if needed.
		gene_micromanage_add_negatives = { WANT = $COST$ }
		if = {
			limit = {
				check_variable = { which = available_trait_points value >= $COST$ }
				check_variable = { which = available_trait_picks value >= 1 }
			}
			# Go ahead and add it.
			modify_species = {
				species = this
				change_scoped_species = yes
				add_trait = $TRAIT$
			}
			subtract_variable = { which = available_trait_points value = $COST$ }
			subtract_variable = { which = available_trait_picks value = 1 }
		}
	}
}

# For Genetic Ascension Only
gene_micromanage_try_add_genetic = {
	if = {
		limit = {
			can_genemod_genetic = yes
			NOT = { has_trait = $TRAIT$ }
		}
		# Add negatives if needed.
		gene_micromanage_add_negatives = { WANT = $COST$ }
		if = {
			limit = {
				check_variable = { which = available_trait_points value >= $COST$ }
				check_variable = { which = available_trait_picks value >= 1 }
			}
			# Go ahead and add it.
			modify_species = {
				species = this
				change_scoped_species = yes
				add_trait = $TRAIT$
			}
			subtract_variable = { which = available_trait_points value = $COST$ }
			subtract_variable = { which = available_trait_picks value = 1 }
		}
	}
}

# For Cybernetic Ascension Only
gene_micromanage_try_add_cyber = {
	if = {
		limit = {
			can_genemod_cybernetic = yes
			NOT = { has_trait = $TRAIT$ }
			has_trait = trait_cybernetic
		}
		# Add negatives if needed.
		gene_micromanage_add_negatives = { WANT = $COST$ }
		if = {
			limit = {
				check_variable = { which = available_trait_points value >= $COST$ }
				check_variable = { which = available_trait_picks value >= 1 }
			}
			# Go ahead and add it.
			modify_species = {
				species = this
				change_scoped_species = yes
				add_trait = $TRAIT$
			}
			subtract_variable = { which = available_trait_points value = $COST$ }
			subtract_variable = { which = available_trait_picks value = 1 }
		}
	}
}

# Add traits back
gene_micromanage_add_traits = {
	optimize_memory
	# If the player has unlocked the psionic tree, make sure the pop is psychic
	# if they aren't cybernetic.
	if = {
		limit = {
			owner = { has_active_tradition = tr_psionics_finish }
			NOT = { pop_has_trait = trait_psionic }
			NOT = { pop_has_trait = trait_cybernetic }
		}
		modify_species = {
			species = this
			change_scoped_species = yes
			add_trait = trait_psionic
			remove_trait = trait_latent_psionic
		}
	}

	# If the player has unlocked the cybernetic tree, make sure the pop is cybernetic
	# unless they are already pychic
	if = {
		limit = {
			owner = { has_active_tradition = tr_cybernetics_finish }
			NOT = { pop_has_trait = trait_psionic }
			NOT = { pop_has_trait = trait_latent_psionic }
			NOT = { pop_has_trait = trait_cybernetic }
		}
		modify_species = {
			species = this
			change_scoped_species = yes
			add_trait = trait_cybernetic
		}
	}

	# tomb_world   (trait_advanced_radiotrophic) 2 Also need Habitability!
	if = {
		limit = {
			planet = { is_planet_class = pc_nuked }
		}
		if = {
			limit = {
				host_has_dlc = "Plantoids Species Pack"
				NOT = { pop_has_trait = trait_voidling }
				NOT = { pop_has_trait = trait_harvested_radiotrophic }
				NOT = { pop_has_trait = trait_plantoid_phototrophic }
				NOT = { pop_has_trait = trait_advanced_phototrophic }
			}
			if = {
				limit = { is_lithoid = yes }
				gene_micromanage_try_add_genetic = { TRAIT = trait_lithoid_radiotrophic COST = 2 }
			}
			else_if = {
				limit = {
					OR = {
						is_species_class = PLANT
						is_species_class = FUN
					}
				}
				gene_micromanage_try_add_genetic = { TRAIT = trait_plantoid_radiotrophic COST = 2 }
			}
			else_if = {
				limit = {
					OR = {
						owner = { has_technology = tech_plantoid_transgenesis }
						owner = { has_technology = tech_lithoid_transgenesis }
					}
					# Advanced Radiotrophic isn't really worth the two points if you have tomb
					# world habitability, as you don't get the growth boost like the plantoid
					# and lithoid versions. These pops will usually instead end up with rapid
					# breeders.
					NOT = { pop_has_trait = trait_pc_nuked_preference }
				}
				gene_micromanage_try_add_genetic = { TRAIT = trait_advanced_radiotrophic COST = 2 }
			}
		}
		if = {
			limit = { planet = { habitability = { who = prev.species value < 0.8 } } }
			# Low Tomb World Habitability. Adding Habitability is more efficient than pretty
			# much any other changes and we can't just change their ideal planet type to Tomb World
			if = {
				limit = { owner = { has_origin = origin_overtuned } }
				gene_micromanage_try_add = { TRAIT = trait_excessive_endurance COST = 3 }
				if = {
					limit = { planet = { habitability = { who = prev.species value < 0.8 } } }
					gene_micromanage_try_add = { TRAIT = trait_spliced_adaptability COST = 1 }
				}
			}
			if = {
				limit = { is_lithoid = no }
				gene_micromanage_try_add_genetic = { TRAIT = trait_robust COST = 4 }
			}
		}
	}
	# ocean (trait_aquatic) 2
	if = {
		limit = {
			host_has_dlc = "Aquatics Species Pack"
			NOT = { pop_has_trait = trait_pc_nuked_preference }
			NOT = { pop_has_trait = trait_pc_habitat_preference }
			OR = {
				owner = { has_technology = tech_glandular_acclimation }
				pop_has_trait = trait_pc_ocean_preference
			}
			OR = {
				planet = { is_planet_class = pc_ocean }
				planet = { has_modifier = flooded_habitat }
			}
			OR = {
				planet = { habitability = { who = prev.species value < 0.81 } }
				has_job_category = worker
				has_job_category = simple_drone
				is_unemployed = yes
			}
		}
		gene_micromanage_try_add_genetic = { TRAIT = trait_aquatic COST = 2 }
	}

	# livestock   trait_delicious/trait_felsic  2
	if = {
		limit = {
			has_citizenship_type = { type = citizenship_slavery }
			OR = {
				has_slavery_type = { type = slavery_livestock }
				has_slavery_type = { type = slavery_matrix }
			}
		}
		if = {
			limit = { is_lithoid = yes }
			gene_micromanage_try_add_genetic = { TRAIT = trait_felsic COST = 2 }
		}
		else = {
			gene_micromanage_try_add_genetic = { TRAIT = trait_delicious COST = 2 }
		}
	}

	# research_(all/some?)   trait_erudite (trait_elevated_synapses, trait_artificial_intelligence)
	# (trait_natural_sociologists/physicists/engineers) 4 + (2 + 1) + (1)
	if = {
		limit = {
			# Proles/Livestock and produce research in a few worker jobs,
			# but they aren't allowed any of these traits.
			NOT = { pop_has_trait = trait_syncretic_proles }
			NOT = { pop_has_trait = trait_presapient_docile_livestock }
			NOT = { pop_has_trait = trait_nerve_stapled }
			OR = {
				pop_produces_resource = { type = society_research amount > 0}
				pop_produces_resource = { type = engineering_research amount > 0}
				pop_produces_resource = { type = physics_research amount > 0}
			}
		}
		# The cyborg one is best if they can do cybernetic.
		gene_micromanage_try_add_cyber = { TRAIT = trait_cyborg_logic_engines COST = 1 }
		# We give the cheap one-type trait next, in a set order. Not necessarily ideal,
		# but it makes the logic simpler, and we shouldn't be point limited for researchers.
		if = {
			limit = { pop_produces_resource = { type = society_research amount > 0} }
			gene_micromanage_try_add_genetic = { TRAIT = trait_natural_sociologists COST = 1 }
		}
		else_if = {
			limit = { pop_produces_resource = { type = engineering_research amount > 0} }
			gene_micromanage_try_add_genetic = { TRAIT = trait_natural_engineers COST = 1 }
		}
		else_if = {
			limit = { pop_produces_resource = { type = physics_research amount > 0} }
			gene_micromanage_try_add_genetic = { TRAIT = trait_natural_physicists COST = 1 }
		}
		
		if = {
			limit = {
				owner = { has_origin = origin_overtuned }
			}
			gene_micromanage_try_add = { TRAIT = trait_elevated_synapses COST = 2 }
			gene_micromanage_try_add = { TRAIT = trait_artificial_intelligence COST = 1 }
		}
		if = {
			# Erudite is allowed for the two bad enigmatic cache traits, but not the good one.
			limit = { NOT = { pop_has_trait = trait_enigmatic_intelligence } }
			gene_micromanage_try_add_genetic = { TRAIT = trait_erudite COST = 4 }
		}
		if = {
			limit = { NOT = { pop_has_trait = trait_erudite } }
			limit = { NOT = { pop_has_trait = trait_enigmatic_intelligence_failed } }
			limit = { NOT = { pop_has_trait = trait_enigmatic_intelligence_poor } }
			# They'll generally only end up with intelligent if they couldn't get erudite.
			gene_micromanage_try_add = { TRAIT = trait_intelligent COST = 2 }
		}
	}

	# unity   trait_traditional (trait_expressed_tradition) 1 + (1)
	if = {
		limit = { pop_produces_resource = { type = unity amount > 0} }
		if = {
			limit = {
				owner = { has_origin = origin_overtuned }
			}
			gene_micromanage_try_add = { TRAIT = trait_expressed_tradition COST = 1 }
		}
		gene_micromanage_try_add = { TRAIT = trait_traditional COST = 1 }
	}
	# alloys|consumer_goods   trait_natural_machinist   2
	if = {
		limit = {
			OR = {
				pop_produces_resource = { type = alloys amount > 0}
				pop_produces_resource = { type = consumer_goods amount > 0}
			}
		}
		gene_micromanage_try_add_genetic = { TRAIT = trait_natural_machinist COST = 2 }
	}

	# minerals   trait_industrious  (trait_crack_miner) 2 + (1)
	if = {
		limit = { pop_produces_resource = { type = minerals amount > 0} }
		if = {
			limit = {
				owner = { has_origin = origin_overtuned }
			}
			gene_micromanage_try_add = { TRAIT = trait_crack_miner COST = 1 }
		}
		gene_micromanage_try_add_cyber = { TRAIT = trait_cyborg_power_drills COST = 1 }
		gene_micromanage_try_add = { TRAIT = trait_industrious COST = 2 }
	}
	# energy   trait_ingenious  (trait_technical_skill) 2 + (1)
	if = {
		limit = { pop_produces_resource = { type = energy amount > 0} }
		if = {
			limit = {
				owner = { has_origin = origin_overtuned }
			}
			gene_micromanage_try_add = { TRAIT = trait_technical_skill COST = 1 }
		}
		gene_micromanage_try_add_cyber = { TRAIT = trait_cyborg_superconductive COST = 1 }
		gene_micromanage_try_add = { TRAIT = trait_ingenious COST = 2 }
	}
	# food   trait_agrarian  (trait_farm_hands) 2 + (1)
	if = {
		limit = { pop_produces_resource = { type = food amount > 0} }
		if = {
			limit = {
				owner = { has_origin = origin_overtuned }
			}
			gene_micromanage_try_add = { TRAIT = trait_farm_hands COST = 1 }
		}
		gene_micromanage_try_add_cyber = { TRAIT = trait_cyborg_harvesters COST = 1 }
		gene_micromanage_try_add = { TRAIT = trait_agrarian COST = 2 }
	}
	# trade_value   trait_thrifty   2
	if = {
		limit = { pop_job_produces_trade = yes }
		gene_micromanage_try_add_cyber = { TRAIT = trait_cyborg_trading_algorithms COST = 1 }
		gene_micromanage_try_add = { TRAIT = trait_thrifty COST = 2 }
	}
	# amenities   trait_charismatic (trait_crafted_smiles) 2 + (1)
	if = {
		limit = { pop_job_produces_amenities = yes }
		if = {
			limit = {
				owner = { has_origin = origin_overtuned }
			}
			gene_micromanage_try_add = { TRAIT = trait_crafted_smiles COST = 1 }
		}
		gene_micromanage_try_add = { TRAIT = trait_charismatic COST = 2 }
	}

	export_modifier_to_variable = {
		modifier = pop_defense_armies_add
		variable = genmod_pop_defense_armies
	}
	# worker    trait_very_strong (trait_juiced_power) 3 + (1)
	if = {
		limit = {
			OR = {
				has_job_category = worker
				has_job_category = simple_drone
				check_variable = { which = genmod_pop_defense_armies value > 0 }
			}
		}
		if = {
			limit = {
				owner = { has_origin = origin_overtuned }
			}
			gene_micromanage_try_add = { TRAIT = trait_juiced_power COST = 1 }
		}
	}
	# Excessive Endurance is strictly better than Very Strong, so we give it first.
	# all_job    (trait_excessive_endurance) (3)
	if = {
		limit = {
			owner = { has_origin = origin_overtuned }
		}
		gene_micromanage_try_add = { TRAIT = trait_excessive_endurance COST = 3 }
	}
	# worker    trait_very_strong|strong 3|1
	if = {
		limit = {
			OR = {
				has_job_category = worker
				has_job_category = simple_drone
				check_variable = { which = genmod_pop_defense_armies value > 0 }
			}
		}
		gene_micromanage_try_add = { TRAIT = trait_very_strong COST = 3 }
		if = {
			limit = { NOT = { pop_has_trait = trait_very_strong } }
			gene_micromanage_try_add = { TRAIT = trait_strong COST = 1 }
		}
	}

	if = {
		limit = { check_variable = { which = genmod_pop_defense_armies value > 0 } }
		# Soldier/Defense Army jobs get a higher priority for resilient
		# We've already given them all the other army damage bonuses above.
		gene_micromanage_try_add_genetic = { TRAIT = trait_resilient COST = 1 }
	}

	# slave worker/livestock    trait_nerve_stapled  3
	if = {
		limit = {
			has_citizenship_type = { type = citizenship_slavery }
			OR = {
				has_slavery_type = { type = slavery_livestock }
				has_slavery_type = { type = slavery_matrix }
				has_job_category = worker
				has_job_category = simple_drone
			}
			NOT = { pop_has_trait = trait_erudite }
			NOT = { pop_has_trait = trait_intelligent }
			NOT = { pop_has_trait = trait_enigmatic_intelligence }
			NOT = { pop_has_trait = trait_zombie }
			NOT = { pop_has_trait = trait_natural_engineers }
			NOT = { pop_has_trait = trait_natural_physicists }
			NOT = { pop_has_trait = trait_natural_sociologists }
			NOT = { pop_has_trait = trait_solitary }
		}
		gene_micromanage_try_add_genetic = { TRAIT = trait_nerve_stapled COST = 3 }
		# Check that we didn't add solitary when added this as they are incompatible.
		if = {
			limit = {
				pop_has_trait = trait_solitary
				pop_has_trait = trait_nerve_stapled
			}
			# Remove both of them add add the points back.
			# Solitary is the last negative we are willing to add, so this means we can't
			# afford nerve stapled any other way. We may have added other negatives too,
			# but we don't care as in this situation we have exactly two points left and
			# at least two picks.
			modify_species = {
				species = this
				change_scoped_species = yes
				remove_trait = trait_solitary
				remove_trait = trait_nerve_stapled
			}
			change_variable = { which = available_trait_points value = 2 }
			change_variable = { which = available_trait_picks value = 2 }
		}
	}

	# Pretty much all cyborgs should end up with efficient processors.
	gene_micromanage_try_add_cyber = { TRAIT = trait_cyborg_efficient_processors COST = 2 }
	# all_job    trait_robust 4
	# Since Robust is so expensive there are situations where it isn't actually the best choice here
	# if we don't need the habitability boost that comes with it, but it's never a bad choice, especially
	# since it will be another ten years before this pop gets modded again and they may have to change
	# jobs in the meantime.
	if = {
		limit = { is_lithoid = no }
		gene_micromanage_try_add_genetic = { TRAIT = trait_robust COST = 4 }
	}

	# Extra traits to use up the rest of our points.
	# growth    trait_fertile/trait_rapid_breeders trait_nomadic
	# (trait_preplanned_growth, trait_incubator)  4/2 + 1 + (2, 2)
	# cyborg_double_jointed 1
	# Incubators only makes sense when the planet population is < 25, we are even more conservative than that.
	if = {
		limit = {
			host_has_dlc = "Toxoids Species Pack"
			planet = { num_pops <= 20 }
			NOT = { pop_has_trait = trait_plantoid_budding }
			NOT = { pop_has_trait = trait_lithoid_budding }
			NOT = { pop_has_trait = trait_advanced_budding }
			NOT = { pop_has_trait = trait_rapid_breeders_lithoid }
		}
		gene_micromanage_try_add_genetic = { TRAIT = trait_incubator COST = 2 }
	}
	if = {
		limit = {
			owner = { has_origin = origin_overtuned }
		}
		gene_micromanage_try_add = { TRAIT = trait_preplanned_growth COST = 2 }
	}
	if = {
		limit = {
			is_lithoid = no
			NOT = { pop_has_trait = trait_incubator }
			NOT = { pop_has_trait = trait_vat_grown }
			NOT = { pop_has_trait = trait_tiyanki }
		}
		gene_micromanage_try_add_genetic = { TRAIT = trait_fertile COST = 4 }
	}
	if = {
		limit = {
			is_lithoid = no
			NOT = { pop_has_trait = trait_incubator }
			NOT = { pop_has_trait = trait_vat_grown }
			NOT = { pop_has_trait = trait_tiyanki }
			NOT = { pop_has_trait = trait_fertile }
			NOT = { pop_has_trait = trait_clone_soldier_infertile }
			NOT = { pop_has_trait = trait_clone_soldier_infertile_full_potential }
		}
		gene_micromanage_try_add = { TRAIT = trait_rapid_breeders COST = 2 }
	}
	# Per Steam comment by @Sayle, durable is more important for hive minds as they spend
	# alot of their population making amenities.
	if = {
		limit = { pop_has_trait = trait_hive_mind }
		gene_micromanage_try_add_cyber = { TRAIT = trait_cyborg_durable COST = 1 }
	}
	gene_micromanage_try_add_cyber = { TRAIT = trait_cyborg_double_jointed COST = 1 }
	gene_micromanage_try_add_genetic = { TRAIT = trait_nomadic COST = 1 }
	# other    trait_docile trait_conservational (trait_low_maintenance)  2 + 1 + (1)
	# for cyborgs: loyalty_circuits durable streamlined_protocols
	if = {
		limit = {
			owner = { has_origin = origin_overtuned }
		}
		gene_micromanage_try_add = { TRAIT = trait_low_maintenance COST = 1 }
	}
	# The best priority order of these cyborg traits is up for debate.
	# The +10% happiness from loyalty circuits probably makes it the best IF the pop is not
	# already at 100% happiness, then it's useless. Durable is good if you are short on amenities
	# otherwise it's useless. Streamlined Protocols is good if you care about empire size, which I
	# think is important, but the AI seems to love to add the opposite High Bandwidth...
	# You could even argue that none of them are worth the 0.3 extra energy upkeep.
	gene_micromanage_try_add_cyber = { TRAIT = trait_cyborg_loyalty_circuits COST = 1 }
	gene_micromanage_try_add_cyber = { TRAIT = trait_cyborg_durable COST = 1 }
	gene_micromanage_try_add_cyber = { TRAIT = trait_cyborg_streamlined_protocols COST = 1 }
	gene_micromanage_try_add_genetic = { TRAIT = trait_docile COST = 2 }
	if = {
		limit = { NOT = { pop_has_trait = trait_hive_mind } }
		gene_micromanage_try_add_genetic = { TRAIT = trait_conservational COST = 1 }
	}
	if = {
		limit = { NOT = { pop_has_trait = trait_very_strong } }
		# Strong isn't really useful, but it's better than resilient
		# and let's them move jobs easier.
		gene_micromanage_try_add_genetic = { TRAIT = trait_strong COST = 1 }
	}
	gene_micromanage_try_add_genetic = { TRAIT = trait_resilient COST = 1 }

	# Talented gives absolutely no benefit since they won't spawn leaders.
	# Really it's just a sign that we ran out of things to give if you see it.
	gene_micromanage_try_add_genetic = { TRAIT = trait_talented COST = 1 }
}

gene_micromanage_account_pick = {
	if = {
		limit = { pop_has_trait = $TRAIT$ }
		subtract_variable = { which = available_trait_picks value = 1 }
		subtract_variable = { which = unaccounted_trait_points value = $COST$ }
	}
}

# Count the number of trait points and picks available for this pop and
# save them to variables.
gene_micromanage_count_traits = {
	optimize_memory
	# The modifiers are in the country scope, so grab them from there and
	# copy the variables to the pop scope.
	owner = {
		export_modifier_to_variable = {
			modifier = BIOLOGICAL_species_trait_points_add
			variable = genemod_available_trait_points
		}
		export_modifier_to_variable = {
			modifier = BIOLOGICAL_species_trait_picks_add
			variable = genemod_available_trait_picks
		}
	}
	set_variable = { which = available_trait_points value = owner.genemod_available_trait_points }
	# 2 + BIOLOGICAL_species_trait_points_add + 1 if half_species
	change_variable = { which = available_trait_points value = 2 }
	# 5 + BIOLOGICAL_species_trait_picks_add + 1 if half_species
	set_variable = { which = available_trait_picks value = owner.genemod_available_trait_picks }
	change_variable = { which = available_trait_picks value = 5 }
	if = {
		limit = { species = { is_half_species = any } }
		change_variable = { which = available_trait_points value = 1 }
		change_variable = { which = available_trait_picks value = 1 }
	}
	# Remove the ones already being used.
	subtract_variable = { which = available_trait_points value = trigger:num_trait_points }
	# zero-cost traits don't count against trait picks, but there doesn't seem to be a way to
	# count them without having a hardcoded list of all the traits, so we'll figure out the vanilla
	# ones, and then assume that one trait pick is used for every remaining used trait point.
	export_trigger_value_to_variable = { trigger = num_trait_points variable = unaccounted_trait_points }
	
	gene_micromanage_account_pick = { TRAIT = trait_adaptive COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_extremely_adaptive COST = 4 }
	gene_micromanage_account_pick = { TRAIT = trait_agrarian COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_charismatic COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_conformists COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_docile COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_venerable COST = 4 }
	gene_micromanage_account_pick = { TRAIT = trait_industrious COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_ingenious COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_intelligent COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_rapid_breeders COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_very_strong COST = 3 }
	gene_micromanage_account_pick = { TRAIT = trait_thrifty COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_nonadaptive COST = -2 }
	gene_micromanage_account_pick = { TRAIT = trait_repugnant COST = -2 }
	gene_micromanage_account_pick = { TRAIT = trait_solitary COST = -1 }
	gene_micromanage_account_pick = { TRAIT = trait_deviants COST = -1 }
	gene_micromanage_account_pick = { TRAIT = trait_wasteful COST = -1 }
	gene_micromanage_account_pick = { TRAIT = trait_unruly COST = -2 }
	gene_micromanage_account_pick = { TRAIT = trait_fleeting COST = -1 }
	gene_micromanage_account_pick = { TRAIT = trait_sedentary COST = -1 }
	gene_micromanage_account_pick = { TRAIT = trait_slow_learners COST = -1 }
	gene_micromanage_account_pick = { TRAIT = trait_slow_breeders COST = -2 }
	gene_micromanage_account_pick = { TRAIT = trait_weak COST = -1 }
	gene_micromanage_account_pick = { TRAIT = trait_quarrelsome COST = -1 }
	gene_micromanage_account_pick = { TRAIT = trait_decadent COST = -1 }
	
	gene_micromanage_account_pick = { TRAIT = trait_lithoid_radiotrophic COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_advanced_radiotrophic COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_plantoid_radiotrophic COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_plantoid_budding COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_advanced_budding COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_lithoid_budding COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_lithoid_gaseous_byproducts COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_advanced_gaseous_byproducts COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_lithoid_scintillating COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_advanced_scintillating COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_lithoid_volatile_excretions COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_advanced_volatile_excretions COST = 2 }

	gene_micromanage_account_pick = { TRAIT = trait_incubator COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_inorganic_breath COST = 3 }

	gene_micromanage_account_pick = { TRAIT = trait_elevated_synapses COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_preplanned_growth COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_excessive_endurance COST = 3 }

	gene_micromanage_account_pick = { TRAIT = trait_aquatic COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_nivlac COST = 2 }

	gene_micromanage_account_pick = { TRAIT = trait_cyborg_efficient_processors COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_cyborg_bulky COST = -2 }
	gene_micromanage_account_pick = { TRAIT = trait_cyborg_high_maintenance COST = -2 }
	gene_micromanage_account_pick = { TRAIT = trait_cyborg_high_bandwidth COST = -2 }
	gene_micromanage_account_pick = { TRAIT = trait_cyborg_neural_limiters COST = -2 }
	gene_micromanage_account_pick = { TRAIT = trait_cyborg_power_intensive COST = -1 }

	gene_micromanage_account_pick = { TRAIT = trait_delicious COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_felsic COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_natural_machinist COST = 2 }
	gene_micromanage_account_pick = { TRAIT = trait_nerve_stapled COST = 3 }
	gene_micromanage_account_pick = { TRAIT = trait_vat_grown COST = 3 }
	gene_micromanage_account_pick = { TRAIT = trait_erudite COST = 4 }
	gene_micromanage_account_pick = { TRAIT = trait_fertile COST = 4 }
	gene_micromanage_account_pick = { TRAIT = trait_robust COST = 4 }

	gene_micromanage_account_pick = { TRAIT = trait_drake_scaled COST = 3 }
	gene_micromanage_account_pick = { TRAIT = trait_tiyanki COST = 3 }
	gene_micromanage_account_pick = { TRAIT = trait_voidling COST = 3 }

	# Everything left is assumed to use one pick per point
	subtract_variable = { which = available_trait_picks value = unaccounted_trait_points }
}

# Effect to micromanage the genes of the scoped pop
gene_micromanage_pop = {
	if = {
		limit = {
			NOT = { pop_has_trait = trait_self_modified }
			NOT = { pop_has_trait = trait_clone_soldier_infertile }
			NOT = { pop_has_trait = trait_clone_soldier_infertile_full_potential }
			is_sapient = yes
		}
		# Remove all the traits that we are willing to remove.
		gene_micromanage_remove_traits = yes

		# Reset habitability to the species baseline. This is just so that
		# we don't have unnecessarily different habitabilities in the subspecies list
		# when they would end up with 100% habitability anyways.
		gene_micromanage_reset_habitability = yes

		# Count how many picks and points we have available.
		gene_micromanage_count_traits = yes

		# Pick traits.
		if = {
			limit = {
				check_variable = { which = available_trait_points value > 0 }
				check_variable = { which = available_trait_picks value > 0 }
			}
			gene_micromanage_add_traits = yes
		}

		# Set ideal habitability if we aren't already at 100%.
		gene_micromanage_habitability = yes

		gene_micromanage_cleanup = yes
	}
}

# Scope this = leader
genemod_enhance_leader_genetic = {
	if = {
		limit = {
			owner = { has_policy_flag = leader_enhancement_custom_genesculpting }
			NOT = { has_leader_flag = genemod_sculpted }
			species = {
				is_robotic = no
				NOT = { has_trait = trait_mechanical }
			}
		}
		species = {
			save_event_target_as = leader_previous_species
		}
		set_leader_flag = genemod_sculpted
		if = {
			limit = { species = { NOT = { has_trait = trait_erudite } } }
			modify_species = {
				add_trait = trait_erudite # Cost 4
			}
		}
		if = {
			limit = { species = { NOT = { has_trait = trait_robust } } }
			modify_species = {
				add_trait = trait_robust # Cost 4
			}
		}
		if = {
			limit = { species = { NOT = { has_trait = trait_venerable } } }
			modify_species = {
				add_trait = trait_venerable # Cost 4
				remove_trait = trait_enduring
				remove_trait = trait_fleeting
			}
		}
		if = {
			limit = { species = { NOT = { has_trait = trait_quick_learners } } }
			modify_species = {
				add_trait = trait_quick_learners # Cost 1
				remove_trait = trait_slow_learners
			}
		}
		if = {
			limit = { species = { NOT = { has_trait = trait_talented } } }
			modify_species = {
				add_trait = trait_talented # Cost 1
			}
		}
		if = {
			limit = {
				owner = { has_origin = origin_overtuned }
			}
			modify_species = {
				remove_trait = trait_spliced_adaptability
				remove_trait = trait_juiced_power
				remove_trait = trait_farm_hands
				remove_trait = trait_crack_miner
				remove_trait = trait_technical_skill
				remove_trait = trait_crafted_smiles
				remove_trait = trait_low_maintenance
				remove_trait = trait_artificial_intelligence
				remove_trait = trait_expressed_tradition
				remove_trait = trait_preplanned_growth
				remove_trait = trait_excessive_endurance
			}
		}
		if = {
			limit = {
				host_has_dlc = "Toxoids Species Pack"
			}
			modify_species = {
				add_trait = trait_exotic_metabolism
			}
		}
	}
}

# Scope this = leader
genemod_enhance_leader_cybernetic = {
	if = {
		limit = {
			owner = { has_policy_flag = leader_enhancement_custom_cybernetics }
			NOT = { has_leader_flag = genemod_cybersculpted }
			species = {
				is_robotic = no
				NOT = { has_trait = trait_mechanical }
			}
		}
		species = {
			save_event_target_as = leader_previous_species
		}
		set_leader_flag = genemod_cybersculpted
		if = {
			# They should already be cyborgs, but we make sure.
			limit = { species = { NOT = { has_trait = trait_cybernetic } } }
			modify_species = {
				add_trait = trait_cybernetic
			}
		}
		if = {
			limit = { species = { NOT = { has_trait = trait_cyborg_enhanced_memory } } }
			modify_species = {
				add_trait = trait_cyborg_enhanced_memory
			}
		}
		if = {
			limit = { species = { NOT = { has_trait = trait_cyborg_learning_algorithms } } }
			modify_species = {
				add_trait = trait_cyborg_learning_algorithms
			}
		}
		# They also get baseline genetic traits.
		if = {
			limit = { species = { NOT = { has_trait = trait_venerable } } }
			modify_species = {
				add_trait = trait_venerable # Cost 4
				remove_trait = trait_enduring
				remove_trait = trait_fleeting
			}
		}
		if = {
			limit = { species = { NOT = { has_trait = trait_quick_learners } } }
			modify_species = {
				add_trait = trait_quick_learners # Cost 1
				remove_trait = trait_slow_learners
			}
		}
		if = {
			limit = { species = { NOT = { has_trait = trait_talented } } }
			modify_species = {
				add_trait = trait_talented # Cost 1
			}
		}
		if = {
			limit = {
				owner = { has_origin = origin_overtuned }
			}
			modify_species = {
				remove_trait = trait_spliced_adaptability
				remove_trait = trait_juiced_power
				remove_trait = trait_farm_hands
				remove_trait = trait_crack_miner
				remove_trait = trait_technical_skill
				remove_trait = trait_crafted_smiles
				remove_trait = trait_low_maintenance
				remove_trait = trait_artificial_intelligence
				remove_trait = trait_expressed_tradition
				remove_trait = trait_preplanned_growth
				remove_trait = trait_excessive_endurance
			}
		}
	}
}

# Scope this = leader
genemod_enhance_leader_psionic = {
	if = {
		limit = {
			owner = { has_policy_flag = leader_enhancement_custom_psionics }
			NOT = { has_leader_flag = genemod_psisculpted }
			species = {
				is_robotic = no
				NOT = { has_trait = trait_mechanical }
			}
		}
		species = {
			save_event_target_as = leader_previous_species
		}
		set_leader_flag = genemod_psisculpted
		if = {
			limit = { species = { NOT = { has_trait = trait_psionic } } }
			modify_species = {
				add_trait = trait_psionic
			}
		}
		# They also get baseline genetic traits.
		if = {
			limit = { species = { NOT = { has_trait = trait_venerable } } }
			modify_species = {
				add_trait = trait_venerable # Cost 4
				remove_trait = trait_enduring
				remove_trait = trait_fleeting
			}
		}
		if = {
			limit = { species = { NOT = { has_trait = trait_quick_learners } } }
			modify_species = {
				add_trait = trait_quick_learners # Cost 1
				remove_trait = trait_slow_learners
			}
		}
		if = {
			limit = { species = { NOT = { has_trait = trait_talented } } }
			modify_species = {
				add_trait = trait_talented # Cost 1
			}
		}
		if = {
			limit = {
				owner = { has_origin = origin_overtuned }
			}
			modify_species = {
				remove_trait = trait_spliced_adaptability
				remove_trait = trait_juiced_power
				remove_trait = trait_farm_hands
				remove_trait = trait_crack_miner
				remove_trait = trait_technical_skill
				remove_trait = trait_crafted_smiles
				remove_trait = trait_low_maintenance
				remove_trait = trait_artificial_intelligence
				remove_trait = trait_expressed_tradition
				remove_trait = trait_preplanned_growth
				remove_trait = trait_excessive_endurance
			}
		}
	}
}

# Scope this = leader
genemod_enhance_leader_robotic = {
	if = {
		limit = {
			owner = { has_policy_flag = leader_enhancement_custom_robots }
			NOT = { owner = { has_policy_flag = ai_outlawed } }
			NOT = { has_leader_flag = genemod_robosculpted }
			OR = {
				owner = { has_technology = tech_robomodding }
				owner = { has_technology = tech_robomodding_m }
			}
			OR = {
				owner = { has_authority = auth_machine_intelligence }
				owner = { has_technology = tech_synthetic_leaders }
			}
			species = {
				is_robotic = yes
			}
		}
		species = {
			save_event_target_as = leader_previous_species
		}
		set_leader_flag = genemod_robosculpted
		if = {
			limit = { species = { NOT = { has_trait = trait_robot_enhanced_memory } } }
			modify_species = {
				add_trait = trait_robot_enhanced_memory
			}
		}
		if = {
			limit = { species = { NOT = { has_trait = trait_robot_learning_algorithms } } }
			modify_species = {
				add_trait = trait_robot_learning_algorithms
				remove_trait = trait_robot_repurposed_hardware
			}
		}
	}
}

# Remove every trait that we are willing to remove to leave a 
# clean slate for customization.
robot_micromanage_remove_traits = {
	optimize_memory
	modify_species = {
		species = this
		change_scoped_species = yes
		remove_trait = trait_robot_power_drills
		remove_trait = trait_robot_harvesters
		remove_trait = trait_robot_superconductive
		remove_trait = trait_robot_efficient_processors
		remove_trait = trait_robot_double_jointed
		remove_trait = trait_robot_emotion_emulators
		remove_trait = trait_robot_durable
		remove_trait = trait_robot_mass_produced
		remove_trait = trait_robot_recycled
		remove_trait = trait_robot_streamlined_protocols
		# Droid Worker Traits
		remove_trait = trait_robot_logic_engines
		remove_trait = trait_robot_propaganda_machines
		remove_trait = trait_robot_trading_algorithms
		# Specialist Synthetics Traits
		remove_trait = trait_robot_loyalty_circuits
		# Robotic Leader Traits
		remove_trait = trait_robot_enhanced_memory
		remove_trait = trait_robot_learning_algorithms
		# Negative Traits
		remove_trait = trait_robot_bulky
		remove_trait = trait_robot_uncanny
		remove_trait = trait_robot_high_maintenance
		remove_trait = trait_robot_repurposed_hardware
		remove_trait = trait_robot_custom_made
		remove_trait = trait_robot_luxurious
		remove_trait = trait_robot_high_bandwidth
	}

	# Remove Domestic Protocols only if they aren't currently a Servant,
	# as doing so would make them ineligible for their current job.
	if = {
		limit = {
			pop_has_trait = trait_robot_domestic_protocols
			NOT = { has_job = servant }
		}
		modify_species = {
			species = this
			change_scoped_species = yes
			remove_trait = trait_robot_domestic_protocols
		}
	}
}

# Count the number of trait points and picks available for this pop and
# save them to variables.
robot_micromanage_count_traits = {
	optimize_memory
	# The modifiers are in the country scope, so grab them from there and
	# copy the variables to the pop scope.
	if = {
		limit = {
			owner = { has_authority = auth_machine_intelligence }
		}
		owner = {
			export_modifier_to_variable = {
				modifier = MACHINE_species_trait_points_add
				variable = genemod_available_trait_points
			}
			export_modifier_to_variable = {
				modifier = MACHINE_species_trait_picks_add
				variable = genemod_available_trait_picks
			}
		}
		set_variable = { which = available_trait_points value = owner.genemod_available_trait_points }
		# Machine Empires start with 1 point and 5 picks.
		change_variable = { which = available_trait_points value = 1 }
		set_variable = { which = available_trait_picks value = owner.genemod_available_trait_picks }
		change_variable = { which = available_trait_picks value = 5 }
	}
	else = {
		owner = {
			export_modifier_to_variable = {
				modifier = ROBOT_species_trait_points_add
				variable = genemod_available_trait_points
			}
			export_modifier_to_variable = {
				modifier = ROBOT_species_trait_picks_add
				variable = genemod_available_trait_picks
			}
		}
		# Robots start with 0 points and 4 picks
		set_variable = { which = available_trait_points value = owner.genemod_available_trait_points }
		set_variable = { which = available_trait_picks value = owner.genemod_available_trait_picks }
		change_variable = { which = available_trait_picks value = 4 }
	}
	

	# Remove the ones already being used.
	subtract_variable = { which = available_trait_points value = trigger:num_trait_points }
	# zero-cost traits don't count against trait picks, but there doesn't seem to be a way to
	# count them without having a hardcoded list of all the traits, so we'll figure out the vanilla
	# ones, and then assume that one trait pick is used for every remaining used trait point.
	export_trigger_value_to_variable = { trigger = num_trait_points variable = unaccounted_trait_points }
	
	# Before calling this function we removed every possible vanilla trait with the possible exception
	# of Domestic Protocols, so that's the only one we check for.
	gene_micromanage_account_pick = { TRAIT = trait_robot_domestic_protocols COST = 2 }

	# Everything left is assumed to use one pick per point
	subtract_variable = { which = available_trait_picks value = unaccounted_trait_points }
}

robot_micromanage_add_trait = {
	modify_species = {
		species = this
		change_scoped_species = yes
		add_trait = $TRAIT$
	}
	subtract_variable = { which = available_trait_points value = $COST$ }
	subtract_variable = { which = available_trait_picks value = 1 }
}

robot_micromanage_add_negatives = {
	# Negative Traits
	# We never add trait_robot_custom_made, it's just not worth it.
	# Everything else is situation dependent.

	set_variable = { which = possible_trait_picks value = available_trait_picks }
	# Need one pick for the positive trait, we never take the last pick with a negative.
	subtract_variable = { which = possible_trait_picks value = 1 }
	if = {
		limit = {
			# Don't add negatives if we don't have to.
			check_variable = { which = available_trait_points value < $WANT$ }
			check_variable = { which = possible_trait_picks value >= 1 }
		}
		# Figure out whether we can get enough points before actually adding any traits
		set_variable = { which = possible_trait_points value = available_trait_points }
		set_variable = { which = needed_trait_points value = $WANT$ }
		subtract_variable = { which = needed_trait_points value = available_trait_points }

		# Special case for when we need exactly one point and have exactly one pick left to get it.
		# We try to choose a one point negative instead of a two pointer.
		if = {
			limit = {
				check_variable = { which = needed_trait_points value = 1 }
				check_variable = { which = possible_trait_picks value = 1 }
			}
			if = {
				limit = {
					can_add_synth_leader_traits = yes
					NOT = { pop_has_trait = trait_robot_repurposed_hardware }
					NOT = { pop_has_trait = trait_robot_learning_algorithms }
				}
				modify_species = {
					species = this
					change_scoped_species = yes
					add_trait = trait_robot_repurposed_hardware
				}
				subtract_variable = { which = available_trait_points value = -1 }
				subtract_variable = { which = available_trait_picks value = 1 }
				modify_species = {
					species = this
					change_scoped_species = yes
					add_trait = trait_robot_repurposed_hardware
				}
				change_variable = { which = available_trait_points value = 1 }
				subtract_variable = { which = available_trait_picks value = 1 }
			}
			else_if = {
				limit = {
					is_species_class = MACHINE
					NOT = { pop_has_trait = trait_robot_uncanny }
					NOT = { pop_has_trait = trait_robot_emotion_emulators }
					pop_job_produces_amenities = no
				}
				modify_species = {
					species = this
					change_scoped_species = yes
					add_trait = trait_robot_uncanny
				}
				change_variable = { which = available_trait_points value = 1 }
				subtract_variable = { which = available_trait_picks value = 1 }
			}
			else_if = {
				limit = {
					NOT = { pop_has_trait = trait_robot_bulky }
					NOT = { pop_has_trait = trait_robot_double_jointed }
					NOT = { has_pop_flag = ADDING_trait_robot_double_jointed }
				}
				modify_species = {
					species = this
					change_scoped_species = yes
					add_trait = trait_robot_bulky
				}
				change_variable = { which = available_trait_points value = 1 }
				subtract_variable = { which = available_trait_picks value = 1 }
			}
			else_if = {
				limit = {
					NOT = { pop_has_trait = trait_robot_custom_made }
					NOT = { pop_has_trait = trait_robot_mass_produced }
					NOT = { has_pop_flag = ADDING_trait_robot_mass_produced }
				}
				modify_species = {
					species = this
					change_scoped_species = yes
					add_trait = trait_robot_custom_made
				}
				change_variable = { which = available_trait_points value = 1 }
				subtract_variable = { which = available_trait_picks value = 1 }
			}
			else_if = {
				limit = {
					NOT = { pop_has_trait = trait_robot_high_maintenance }
					NOT = { pop_has_trait = trait_robot_durable }
					NOT = { has_pop_flag = ADDING_trait_robot_durable }
				}
				modify_species = {
					species = this
					change_scoped_species = yes
					add_trait = trait_robot_high_maintenance
				}
				change_variable = { which = available_trait_points value = 1 }
				subtract_variable = { which = available_trait_picks value = 1 }
			}
		}

		if = {
			limit = {
				# Didn't add something in the special case above.
				check_variable = { which = available_trait_points value < $WANT$ }
				check_variable = { which = possible_trait_picks value >= 1 }
			}
			# Go through and figure out if we can add enough points to let us add the positive
			# trait that we want. If we can't, don't add anything.
			if = {
				limit = {
					check_variable = { which = possible_trait_picks value >= 1 }
					NOT = { pop_has_trait = trait_robot_high_bandwidth }
					NOT = { pop_has_trait = trait_robot_streamlined_protocols }
					NOT = { has_pop_flag = ADDING_trait_robot_streamlined_protocols }
				}
				change_variable = { which = possible_trait_points value = 2 }
				subtract_variable = { which = possible_trait_picks value = 1 }
			}
			if = {
				limit = {
					check_variable = { which = possible_trait_picks value >= 1 }
					NOT = { pop_has_trait = trait_robot_luxurious }
					NOT = { pop_has_trait = trait_robot_recycled }
					NOT = { has_pop_flag = ADDING_trait_robot_recycled }
				}
				change_variable = { which = possible_trait_points value = 2 }
				subtract_variable = { which = possible_trait_picks value = 1 }
			}
			if = {
				limit = {
					check_variable = { which = possible_trait_picks value >= 1 }
					can_add_synth_leader_traits = yes
					NOT = { pop_has_trait = trait_robot_repurposed_hardware }
					NOT = { pop_has_trait = trait_robot_learning_algorithms }
				}
				change_variable = { which = possible_trait_points value = 1 }
				subtract_variable = { which = possible_trait_picks value = 1 }
			}
			if = {
				limit = {
					check_variable = { which = possible_trait_picks value >= 1 }
					is_species_class = MACHINE
					NOT = { pop_has_trait = trait_robot_uncanny }
					NOT = { pop_has_trait = trait_robot_emotion_emulators }
					pop_job_produces_amenities = no
				}
				change_variable = { which = possible_trait_points value = 1 }
				subtract_variable = { which = possible_trait_picks value = 1 }
			}
			if = {
				limit = {
					check_variable = { which = possible_trait_picks value >= 1 }
					NOT = { pop_has_trait = trait_robot_bulky }
					NOT = { pop_has_trait = trait_robot_double_jointed }
					NOT = { has_pop_flag = ADDING_trait_robot_double_jointed }
				}
				change_variable = { which = possible_trait_points value = 1 }
				subtract_variable = { which = possible_trait_picks value = 1 }
			}
			if = {
				limit = {
					check_variable = { which = possible_trait_picks value >= 1 }
					NOT = { pop_has_trait = trait_robot_custom_made }
					NOT = { pop_has_trait = trait_robot_mass_produced }
					NOT = { has_pop_flag = ADDING_trait_robot_mass_produced }
				}
				change_variable = { which = possible_trait_points value = 1 }
				subtract_variable = { which = possible_trait_picks value = 1 }
			}
			if = {
				limit = {
					check_variable = { which = possible_trait_picks value >= 1 }
					NOT = { pop_has_trait = trait_robot_high_maintenance }
					NOT = { pop_has_trait = trait_robot_durable }
					NOT = { has_pop_flag = ADDING_trait_robot_durable}
				}
				change_variable = { which = possible_trait_points value = 1 }
				subtract_variable = { which = possible_trait_picks value = 1 }
			}

			if = {
				limit = {
					check_variable = { which = possible_trait_points value >= $WANT$ }
				}
				# We can do it. Now actually add them.
				if = {
					limit = {
						NOT = { pop_has_trait = trait_robot_high_bandwidth }
						NOT = { pop_has_trait = trait_robot_streamlined_protocols }
						NOT = { has_pop_flag = ADDING_trait_robot_streamlined_protocols }
						check_variable = { which = available_trait_points value < $WANT$ }
					}
					modify_species = {
						species = this
						change_scoped_species = yes
						add_trait = trait_robot_high_bandwidth
					}
					change_variable = { which = available_trait_points value = 2 }
					subtract_variable = { which = available_trait_picks value = 1 }
				}
				if = {
					limit = {
						NOT = { pop_has_trait = trait_robot_luxurious }
						NOT = { pop_has_trait = trait_robot_recycled }
						NOT = { has_pop_flag = ADDING_trait_robot_recycled }
						check_variable = { which = available_trait_points value < $WANT$ }
					}
					modify_species = {
						species = this
						change_scoped_species = yes
						add_trait = trait_robot_luxurious
					}
					change_variable = { which = available_trait_points value = 2 }
					subtract_variable = { which = available_trait_picks value = 1 }
				}
				if = {
					limit = {
						can_add_synth_leader_traits = yes
						NOT = { pop_has_trait = trait_robot_repurposed_hardware }
						NOT = { pop_has_trait = trait_robot_learning_algorithms }
						check_variable = { which = available_trait_points value < $WANT$ }
					}
					modify_species = {
						species = this
						change_scoped_species = yes
						add_trait = trait_robot_repurposed_hardware
					}
					change_variable = { which = available_trait_points value = 1 }
					subtract_variable = { which = available_trait_picks value = 1 }
				}
				if = {
					limit = {
						is_species_class = MACHINE
						NOT = { pop_has_trait = trait_robot_uncanny }
						NOT = { pop_has_trait = trait_robot_emotion_emulators }
						pop_job_produces_amenities = no
						check_variable = { which = available_trait_points value < $WANT$ }
					}
					modify_species = {
						species = this
						change_scoped_species = yes
						add_trait = trait_robot_uncanny
					}
					change_variable = { which = available_trait_points value = 1 }
					subtract_variable = { which = available_trait_picks value = 1 }
				}
				if = {
					limit = {
						NOT = { pop_has_trait = trait_robot_bulky }
						NOT = { pop_has_trait = trait_robot_double_jointed }
						NOT = { has_pop_flag = ADDING_trait_robot_double_jointed }
						check_variable = { which = available_trait_points value < $WANT$ }
					}
					modify_species = {
						species = this
						change_scoped_species = yes
						add_trait = trait_robot_bulky
					}
					change_variable = { which = available_trait_points value = 1 }
					subtract_variable = { which = available_trait_picks value = 1 }
				}
				if = {
					limit = {
						NOT = { pop_has_trait = trait_robot_custom_made }
						NOT = { pop_has_trait = trait_robot_mass_produced }
						NOT = { has_pop_flag = ADDING_trait_robot_mass_produced }
						check_variable = { which = available_trait_points value < $WANT$ }
					}
					modify_species = {
						species = this
						change_scoped_species = yes
						add_trait = trait_robot_custom_made
					}
					change_variable = { which = available_trait_points value = 1 }
					subtract_variable = { which = available_trait_picks value = 1 }
				}
				if = {
					limit = {
						NOT = { pop_has_trait = trait_robot_high_maintenance }
						NOT = { pop_has_trait = trait_robot_durable }
						NOT = { has_pop_flag = ADDING_trait_robot_durable }
						check_variable = { which = available_trait_points value < $WANT$ }
					}
					modify_species = {
						species = this
						change_scoped_species = yes
						add_trait = trait_robot_high_maintenance
					}
					change_variable = { which = available_trait_points value = 1 }
					subtract_variable = { which = available_trait_picks value = 1 }
				}
			}
		}
	}
	
}

robot_micromanage_add_single_negative = {
	if = {
		limit = {
			can_add_synth_leader_traits = yes
			NOT = { pop_has_trait = trait_robot_repurposed_hardware }
			NOT = { pop_has_trait = trait_robot_learning_algorithms }
		}
		robot_micromanage_add_trait = { TRAIT = trait_robot_repurposed_hardware COST = -1 }
	}
	else_if = {
		limit = {
			is_species_class = MACHINE
			NOT = { pop_has_trait = trait_robot_uncanny }
			NOT = { pop_has_trait = trait_robot_emotion_emulators }
			pop_job_produces_amenities = no
		}
		robot_micromanage_add_trait = { TRAIT = trait_robot_uncanny COST = -1 }
	}
	else_if = {
		limit = {
			NOT = { pop_has_trait = trait_robot_bulky }
			NOT = { pop_has_trait = trait_robot_double_jointed }
			NOT = { has_pop_flag = ADDING_trait_robot_double_jointed }
		}
		robot_micromanage_add_trait = { TRAIT = trait_robot_bulky COST = -1 }
	}
	else_if = {
		limit = {
			NOT = { pop_has_trait = trait_robot_custom_made }
			NOT = { pop_has_trait = trait_robot_mass_produced }
			NOT = { has_pop_flag = ADDING_trait_robot_mass_produced }
		}
		robot_micromanage_add_trait = { TRAIT = trait_robot_custom_made COST = -1 }
	}
	else_if = {
		limit = {
			NOT = { pop_has_trait = trait_robot_high_maintenance }
			NOT = { pop_has_trait = trait_robot_durable }
			NOT = { has_pop_flag = ADDING_trait_robot_durable }
		}
		robot_micromanage_add_trait = { TRAIT = trait_robot_high_maintenance COST = -1 }
	}
}

robot_micromanage_swap_negatives = {
	optimize_memory
	if = {
		limit = {
			check_variable = { which = available_trait_picks value > 0 }
		}
		# We have extra trait picks, so swap out a two-point negative for two
		# one-pointers if we can.
		if = {
			limit = {
				OR = {
					pop_has_trait = trait_robot_luxurious
					pop_has_trait = trait_robot_high_bandwidth
				}
				calc_true_if = {
					amount >= 2
					AND = {
						can_add_synth_leader_traits = yes
						NOT = { pop_has_trait = trait_robot_repurposed_hardware }
						NOT = { pop_has_trait = trait_robot_learning_algorithms }
					}
					AND = {
						is_species_class = MACHINE
						NOT = { pop_has_trait = trait_robot_uncanny }
						NOT = { pop_has_trait = trait_robot_emotion_emulators }
						pop_job_produces_amenities = no
					}
					AND = {
						NOT = { pop_has_trait = trait_robot_bulky }
						NOT = { pop_has_trait = trait_robot_double_jointed }
					}
					AND = {
						NOT = { pop_has_trait = trait_robot_custom_made }
						NOT = { pop_has_trait = trait_robot_mass_produced }
					}
					AND = {
						NOT = { pop_has_trait = trait_robot_high_maintenance }
						NOT = { pop_has_trait = trait_robot_durable }
					}
				}
			}
			# We should be able to swap.
			if = {
				limit = { pop_has_trait = trait_robot_luxurious }
				modify_species = {
					species = this
					change_scoped_species = yes
					remove_trait = trait_robot_luxurious
				}
				subtract_variable = { which = available_trait_points value = 2 }
				change_variable = { which = available_trait_picks value = 1 }
				robot_micromanage_add_single_negative = yes
				if = {
					limit = { check_variable = { which = available_trait_points value < 0 } }
					robot_micromanage_add_single_negative = yes
				}
			}
			else_if = {
				limit = { pop_has_trait = trait_robot_high_bandwidth }
				modify_species = {
					species = this
					change_scoped_species = yes
					remove_trait = trait_robot_high_bandwidth
				}
				subtract_variable = { which = available_trait_points value = 2 }
				change_variable = { which = available_trait_picks value = 1 }
				robot_micromanage_add_single_negative = yes
				if = {
					limit = { check_variable = { which = available_trait_points value < 0 } }
					robot_micromanage_add_single_negative = yes
				}
			}
		}
	}
	if = {
		limit = {
			check_variable = { which = available_trait_points value > 0 }
		}
		# We have extra trait points, so swap a negative two-pointer for a one-pointer.
		# We could also remove one-pointers, but we should never end up with single
		# point negatives if we have extra points.
		if = {
			limit = {
				OR = {
					pop_has_trait = trait_robot_luxurious
					pop_has_trait = trait_robot_high_bandwidth
				}
				OR = {
					AND = {
						can_add_synth_leader_traits = yes
						NOT = { pop_has_trait = trait_robot_repurposed_hardware }
						NOT = { pop_has_trait = trait_robot_learning_algorithms }
					}
					AND = {
						is_species_class = MACHINE
						NOT = { pop_has_trait = trait_robot_uncanny }
						NOT = { pop_has_trait = trait_robot_emotion_emulators }
						pop_job_produces_amenities = no
					}
					AND = {
						NOT = { pop_has_trait = trait_robot_bulky }
						NOT = { pop_has_trait = trait_robot_double_jointed }
					}
					AND = {
						NOT = { pop_has_trait = trait_robot_custom_made }
						NOT = { pop_has_trait = trait_robot_mass_produced }
					}
					AND = {
						NOT = { pop_has_trait = trait_robot_high_maintenance }
						NOT = { pop_has_trait = trait_robot_durable }
					}
				}
			}
			# We should be able to swap.
			if = {
				limit = { pop_has_trait = trait_robot_luxurious }
				modify_species = {
					species = this
					change_scoped_species = yes
					remove_trait = trait_robot_luxurious
				}
				subtract_variable = { which = available_trait_points value = 2 }
				change_variable = { which = available_trait_picks value = 1 }
				robot_micromanage_add_single_negative = yes
			}
			else_if = {
				limit = { pop_has_trait = trait_robot_high_bandwidth }
				modify_species = {
					species = this
					change_scoped_species = yes
					remove_trait = trait_robot_high_bandwidth
				}
				subtract_variable = { which = available_trait_points value = 2 }
				change_variable = { which = available_trait_picks value = 1 }
				robot_micromanage_add_single_negative = yes
			}
		}
	}
}

robot_micromanage_try_add = {
	if = {
		limit = {
			NOT = { has_trait = $TRAIT$ }
		}
		# Add negatives if needed.
		set_pop_flag = ADDING_$TRAIT$
		robot_micromanage_add_negatives = { WANT = $COST$ }
		remove_pop_flag = ADDING_$TRAIT$
		if = {
			limit = {
				check_variable = { which = available_trait_points value >= $COST$ }
				check_variable = { which = available_trait_picks value >= 1 }
			}
			# Go ahead and add it.
			robot_micromanage_add_trait = { TRAIT = $TRAIT$ COST = $COST$ }
		}
	}
}

# Add traits back
robot_micromanage_add_traits = {
	# research
	if = {
		limit = {
			can_add_droid_traits = yes
			OR = {
				pop_produces_resource = { type = society_research amount > 0}
				pop_produces_resource = { type = engineering_research amount > 0}
				pop_produces_resource = { type = physics_research amount > 0}
			}
		}
		robot_micromanage_try_add = { TRAIT = trait_robot_logic_engines COST = 2 }
	}
	# unity
	if = {
		limit = {
			can_add_droid_traits = yes
			NOT = { owner = { has_authority = auth_machine_intelligence } }
			pop_produces_resource = { type = unity amount > 0}
		}
		robot_micromanage_try_add = { TRAIT = trait_robot_propaganda_machines COST = 1 }
	}
	# minerals
	if = {
		limit = { pop_produces_resource = { type = minerals amount > 0} }
		robot_micromanage_try_add = { TRAIT = trait_robot_power_drills COST = 2 }
	}
	# energy
	if = {
		limit = { pop_produces_resource = { type = energy amount > 0} }
		robot_micromanage_try_add = { TRAIT = trait_robot_superconductive COST = 2 }
	}
	# food
	if = {
		limit = {
			NOT = { owner = { has_authority = auth_machine_intelligence } }
			pop_produces_resource = { type = food amount > 0}
		}
		robot_micromanage_try_add = { TRAIT = trait_robot_harvesters COST = 2 }
	}
	# trade_value
	if = {
		limit = {
			can_add_droid_traits = yes
			NOT = { owner = { has_authority = auth_machine_intelligence } }
			pop_job_produces_trade = yes
		}
		robot_micromanage_try_add = { TRAIT = trait_robot_trading_algorithms COST = 2 }
	}
	# amenities
	if = {
		limit = {
			OR = {
				pop_job_produces_amenities = yes
				AND = {
					has_citizenship_type = { type = citizenship_robot_servitude }
					is_unemployed = yes
				}
			}
		}
		if = {
			limit = { owner = { has_authority = auth_machine_intelligence } }
			robot_micromanage_try_add = { TRAIT = trait_robot_emotion_emulators COST = 1 }
		}
		else_if = {
			limit = { can_add_droid_traits = yes }
			robot_micromanage_try_add = { TRAIT = trait_robot_domestic_protocols COST = 2 }
		}
	}
	# all_jobs
	robot_micromanage_try_add = { TRAIT = trait_robot_efficient_processors COST = 3 }
	# other
	robot_micromanage_try_add = { TRAIT = trait_robot_mass_produced COST = 1 }
	if = {
		limit = { NOT = { pop_has_trait = trait_robot_luxurious } }
		robot_micromanage_try_add = { TRAIT = trait_robot_recycled COST = 2 }
	}
	if = {
		limit = { NOT = { pop_has_trait = trait_robot_high_maintenance } }
		robot_micromanage_try_add = { TRAIT = trait_robot_durable COST = 1 }
	}
	if = {
		limit = { can_add_synth_traits = yes }
		robot_micromanage_try_add = { TRAIT = trait_robot_loyalty_circuits COST = 2 }
	}
	if = {
		limit = { NOT = { pop_has_trait = trait_robot_high_bandwidth } }
		robot_micromanage_try_add = { TRAIT = trait_robot_streamlined_protocols COST = 2 }
	}
	if = {
		limit = { NOT = { pop_has_trait = trait_robot_bulky } }
		robot_micromanage_try_add = { TRAIT = trait_robot_double_jointed COST = 1 }
	}
}

robot_micromanage_pop = {
	if = {
		limit = {
			NOT = { pop_has_trait = trait_self_modified }
			OR = {
				# Robotic species should always have one of these two.
				# If they don't, we don't touch them as they might be something weird
				# that this mod doesn't know how to deal with.
				pop_has_trait = trait_mechanical
				pop_has_trait = trait_machine_unit
			}
		}
		# Remove all the traits that we are willing to remove.
		robot_micromanage_remove_traits = yes

		# Count how many picks and points we have available.
		robot_micromanage_count_traits = yes

		# Pick traits.
		if = {
			limit = {
				check_variable = { which = available_trait_points value > 0 }
				check_variable = { which = available_trait_picks value > 0 }
			}
			robot_micromanage_add_traits = yes
		}

		# Swap negative traits if we have extra picks.
		robot_micromanage_swap_negatives = yes

		gene_micromanage_cleanup = yes
	}
}
